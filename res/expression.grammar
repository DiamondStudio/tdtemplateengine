@m {
#import <TDTemplateEngine/XPBooleanValue.h>
#import <TDTemplateEngine/XPNumericValue.h>
#import <TDTemplateEngine/XPStringValue.h>
#import <TDTemplateEngine/XPBooleanExpression.h>
#import <TDTemplateEngine/XPRelationalExpression.h>
#import <TDTemplateEngine/XPArithmeticExpression.h>
}

@extension {
@property (nonatomic, retain) PKToken *openParen;
}

@init {
    self.openParen = [PKToken tokenWithTokenType:PKTokenTypeSymbol stringValue:@"(" doubleValue:0.0];
}

@dealloc {
    self.openParen = nil;
}

@before {
    PKTokenizer *t = self.tokenizer;
    [t.symbolState add:@"=="];
    [t.symbolState add:@"!="];
    [t.symbolState add:@"<="];
    [t.symbolState add:@">="];
    [t.symbolState add:@"&&"];
    [t.symbolState add:@"||"];
}

expr    = orExpr;

orOp 	=  'or'! | '||'!;
orExpr  = andExpr (orOp andExpr {
	XPValue *rhs = POP();
	XPValue *lhs = POP();
    PUSH([XPBooleanExpression booleanExpressionWithOperand:lhs operator:XP_TOKEN_KIND_OR operand:rhs]);
})*;

andOp 	= 'and'! | '&&'!;
andExpr = equalityExpr (andOp equalityExpr {
	XPValue *rhs = POP();
	XPValue *lhs = POP();
    PUSH([XPBooleanExpression booleanExpressionWithOperand:lhs operator:XP_TOKEN_KIND_AND operand:rhs]);
})*;

eqOp 	@after { PUSH(@(XP_TOKEN_KIND_EQ)); }
		=  '='! | '=='! | 'eq'!;
neOp 	@after { PUSH(@(XP_TOKEN_KIND_NE)); }
		= '!='! | '!='! | 'ne'!;
equalityExpr = relationalExpr ((eqOp | neOp) relationalExpr {
	XPValue *rhs = POP();
	NSInteger op = POP_INT();
	XPValue *lhs = POP();
    PUSH([XPRelationalExpression relationalExpressionWithOperand:lhs operator:op operand:rhs]);
})*;

ltOp 	@after { PUSH(@(XP_TOKEN_KIND_LT)); }
		=  '<'! | 'lt'!;
gtOp 	@after { PUSH(@(XP_TOKEN_KIND_GT)); }
		=  '>'! | 'gt'!;
leOp 	@after { PUSH(@(XP_TOKEN_KIND_LE)); }
		= '<='! | 'le'!;
geOp 	@after { PUSH(@(XP_TOKEN_KIND_GE)); }
		= '>='! | 'ge'!;
relationalExpr = additiveExpr ((ltOp | gtOp | leOp | geOp) additiveExpr {
	XPValue *rhs = POP();
	NSInteger op = POP_INT();
	XPValue *lhs = POP();
    PUSH([XPRelationalExpression relationalExpressionWithOperand:lhs operator:op operand:rhs]);
})*;

plus	@after { PUSH(@(XP_TOKEN_KIND_PLUS)); }
		= '+'!;
minus	@after { PUSH(@(XP_TOKEN_KIND_MINUS)); }
		= '-'!;
additiveExpr = multiplicativeExpr ((plus | minus) multiplicativeExpr {
	XPValue *rhs = POP();
	NSInteger op = POP_INT();
	XPValue *lhs = POP();
    PUSH([XPArithmeticExpression arithmeticExpressionWithOperand:lhs operator:op operand:rhs]);
})*;

times	@after { PUSH(@(XP_TOKEN_KIND_TIMES)); }
		= '*'!;
div		@after { PUSH(@(XP_TOKEN_KIND_DIV)); }
		= '/'!;
mod		@after { PUSH(@(XP_TOKEN_KIND_MOD)); }
		= '%'!;
multiplicativeExpr = unaryExpr ((times | div | mod) unaryExpr {
	XPValue *rhs = POP();
	NSInteger op = POP_INT();
	XPValue *lhs = POP();
    PUSH([XPArithmeticExpression arithmeticExpressionWithOperand:lhs operator:op operand:rhs]);
})*;
unaryExpr = '-'* primary;
primary = atom | subExpr;

subExpr
    = '(' expr ')'! {
    NSArray *objs = ABOVE(_openParen);
    POP(); // discard `(`
    for (id obj in [objs reverseObjectEnumerator]) {
        PUSH(obj);
    \}
};

atom    = literal;
literal = str | num | bool;
bool
    = true { PUSH([XPBooleanValue booleanValueWithBoolean:YES]); }
    | false { PUSH([XPBooleanValue booleanValueWithBoolean:NO]); }
    ;

true = 'true'! | 'YES'!;
false = 'false'! | 'NO'!;

num = Number {
    PUSH([XPNumericValue numericValueWithNumber:POP_DOUBLE()]);
};

str = QuotedString {
    PUSH([XPStringValue stringValueWithString:POP_QUOTED_STR()]);
};